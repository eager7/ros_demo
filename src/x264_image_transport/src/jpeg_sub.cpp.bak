#include <ros/ros.h>
#include <image_transport/image_transport.h>
#include <opencv2/highgui/highgui.hpp>
#include <cv_bridge/cv_bridge.h>
#include <sys/socket.h>
#include <arpa/inet.h>

static cv::Mat matEle;
bool init_server(int fd); 
bool send_image(int fd);

void imageCallback(const sensor_msgs::ImageConstPtr& msg)
{
  try
  {
//    cv::resizeWindow("view", 800, 100);
//    cv::moveWindow("view", 220, 300);
    matEle = cv_bridge::toCvShare(msg, "bgr8")->image;
    cv::imshow("view", matEle);
  }
  catch (cv_bridge::Exception& e)
  {
    ROS_ERROR("Could not convert from '%s' to 'bgr8'.", msg->encoding.c_str());
  }
}

void* new_thread(void*) {
  int socketfd;
  socketfd = socket(AF_INET, SOCK_STREAM, 0);
  if (socketfd == -1) {
    printf("create socket failed.............\n");
    return NULL;
  }
  struct sockaddr_in server;
  char *readin;
  bzero(&server,sizeof(server)); 
  server.sin_family = AF_INET;
  server.sin_addr.s_addr = INADDR_ANY;
  server.sin_port = htons(33444);
  if (bind(socketfd, (struct sockaddr *)&server, sizeof(server)) < 0) {
    printf("bind failed..................");
    fprintf(stderr, "bind Error:%s\n", strerror(errno));   
    return NULL;
  }

  listen(socketfd, 3);
  printf("wating............\n");
  while (true) {
    init_server(socketfd);
  }
  close(socketfd);
  fflush(stdout);
}

bool init_server(int fd) {
  struct sockaddr_in client;
  int c = sizeof(struct sockaddr_in);
  int new_socket = accept(fd, (struct sockaddr *)&client, (socklen_t *)&c);
  if (new_socket == -1) {
    printf("connected error .......................\n");
  } else {
    printf("new client addr :: %08x", ntohl(client.sin_addr.s_addr));
  }

  fflush(stdout);
  if (new_socket < 0) {
    printf("accept failed...........................................\n");
    return false;
  }
  return send_image(new_socket);
}

bool send_image(int fd) {
  char ch_flags[256] = {0};
  if (read(fd, ch_flags, sizeof(ch_flags)) < 0) {
    printf("read ..failed ..................\n");
    fprintf(stderr, "Read Error:%s\n", strerror(errno));   
  }
  printf("sizoe ch[] = %d\n", sizeof(ch_flags));
  printf("got ch[0] = %x\n", ch_flags[0]);
  std::vector<uchar> buff;
  imencode(".bmp", matEle, buff);
  int len = buff.size();
  printf("sending picture size %d, %x\n", len, len);
  if (write(fd, (void *)&len, sizeof(int))) {
  //char buf[254] = "fslkafjafja;sfas\n";
  //if (write(fd, buf, 254) < 0) {
    printf("write failed %d\n", __LINE__);
    fprintf(stderr, "wite Error:%s\n", strerror(errno));   
  }

  printf("sending Picture as Byte Arraya\n");
  int len_already = 0;
  int o_size = 10240;
  while (len > len_already) {
    int sent_size = 0;
    if (len - len_already >= o_size) {  
      sent_size = write(fd, ((char *) &buff + len_already), o_size);
    } else {
      int diff_len = len - len_already;
      sent_size = write(fd, ((char *) &buff + len_already), diff_len);
    }
    if (sent_size > 0) {
      len_already += sent_size;
      printf("sent_size = %d, len_already = %d\n", sent_size, len_already);
    }
  }
  printf("send done .......................\n");
  return true;
}

int main(int argc, char **argv)
{
  ros::init(argc, argv, "image_listener");
  ros::NodeHandle nh;
  cv::namedWindow("view");
  cv::startWindowThread();
  image_transport::ImageTransport it(nh);
  image_transport::Subscriber sub = it.subscribe("camera/image", 1, imageCallback);
  pthread_t send_thread;
  pthread_create(&send_thread, NULL, new_thread, NULL);
  ros::spin();
  cv::destroyWindow("view");
}
